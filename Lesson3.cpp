// 第二章 02 基本内置类型
#include <iostream>

int main(int argc, char const *argv[]) {
    /**
     * 1.内置类型
     *  算术类型（整型，浮点型）
     *  空类型（void）
     * 2.复合类型（引用，指针）
     * 3.自定义类型（类，结构体）
     */

    /**
     * 在四种整型中，尽量选择int执行整数运算。超过int范围时使用long long。
     * 在三种浮点类型种，选择double执行浮点数运算。因为float常常精度不够，而long double又精度太高。
     */

    /**
     * 带符号类型和无符号类型
     * 除了bool和扩展的字符类型，其他整型都可以划分为带符号的（signed）和无符号的（unsigned）两种。
     * 其中char比较特殊，不同的编译器对char的处理方式不同，有可能被当成signed char来处理，也可能被当成unsigned char。
     * 因此最好在声明时指明有无符号。
     */

    /**
     * 类型转换
     * 在程序中，当我们使用的类型和期望的类型不一致时，程序会自动进行类型转换。
     */
     // 假设char占8比特
     unsigned char c1 = -1; // c1的值为255
     signed char c2 = 256; // c2的值是未定义的

    /**
     * 上面的例子分别说明了下面两种情况：
     * 1.当我们赋给无符号类型一个超出它的表示范围的值时
     * 2.当我们赋给带符号类型一个超出它的表示范围的值时
     *
     * 第一种情况，结果是初始值对无符号类型表示数值总数取模后的余数
     * 第二种情况，会产生未定义的行为，程序可能工作，可能崩溃，可能产生垃圾数据
     */

    /**
     * 数据类型是程序的基础：它告诉我们数据的意义以及我们能在数据上执行的操作
     * 避免将超出范围的值赋值给变量
     * 切勿混用带符号类型和无符号类型
     */
     return 0;
}
