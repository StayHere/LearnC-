#include <iostream>

int main() {
    // 语句
    // 最简单的语句：空语句
    ;   // 空语句
    while (cin >> s && s != sought)
        ;   // 空语句,语法上需要一条语句，但逻辑上不需要

    // 别漏写分号，也别多写分号
    ival = v1 + v2;;    // 正确：第二个分号表示一条多余的空语句

    // 多余的空语句一般来说是无害的，但是如果在if或者while的条件后面跟了一个额外的分号就可能改变程序的初衷

    // 出现了糟糕的情况：额外的分号，循环体是那条空语句
    // 下段代码将陷入死循环
    while (iter != svec.end()) ;    // while循环体是那条空语句
        ++iter;                     // 递增运算不属于循环的一部分

    // 复合语句（块）
    // 复合语句指用花括号括起来的（可能为空的）语句和声明的序列，也称作块
    // 一个快就是一个作用域

    // 如果在程序的某个地方，语法上需要一条语句，但是逻辑上需要多条语句，则应该使用复合语句
    // 例如，while或者for的循环体必须是一条语句，但是我们常常需要在循环体中做很多事情，此时就需要将多条语句用花括号括起来

    while (val <= 10) {
        sum += val;     // 把sum + val的值赋给sum
        ++val;          // 给val加1
    }

    // 块不以分号作为结束
    // 空快指内部没有任何语句的一对花括号，等价于空语句
    while (cin >> s && s != sought) {}  // 空快

    // 语句作用域
    // 定义在控制结构当中的变量只在相应语句的内部可见，语句结束，变量也就超出其作用范围
    while (int i = get_num())  // 每次迭代时创建并初始化i
        cout << i << endl;
    i = 0;  // 错误：在循环外部无法访问i

    // 如果其他代码也需要访问控制变量，则变量必须定义在语句的外部
    auto beg = v.begin();
    while (beg != v.end() && *beg >= 0)
        ++beg;
    if (beg == v.end()) {

    }

    // 当一个if语句嵌套在另一个if语句内部时，可能if分支会多于else分支，这时，怎么知道某个给定的else是和哪个if匹配的？
    // 这个问题通常称为悬垂else，就C++而言，规定else与离它最近的尚未匹配的if匹配，从而消除程序的二义性。
    if (grade % 10 >= 3)
        if (grade % 10 > 7)
            lettergrade += '+';
        else
            lettergrade += '-';

    // 要想使上一段代码else分支和外层的if语句匹配起来，可以在内层if语句的两端加上花括号，使其成为一个块
    if (grade % 10 >= 3) {
        if (grade % 10 > 7)
            lettergrade += '+';
    } else
            lettergrade += '-';

    // switch语句
    // case关键字和它对应的值一起被成为case标签，case标签必须是整型常量表达式
    // 任何两个case标签的值不能相同，否则就会引发错误，default是一种特殊的case标签
    // 标签不应该单独出现，它后面必须跟上一条语句或者另外一个case标签。
    // 如果switch结构以一个空的default标签作为结束，则该default标签后面必须跟上一条空语句或者一个空块

    // 如果在某一处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是非法行为
    // 如果需要为某个case分支定义并初始化一个变量，应该把变量定义在块内。
}
