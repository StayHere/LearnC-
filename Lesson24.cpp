C++定义了一元运算符，二元运算符，三元运算符。
一元运算符作用于一个对象，如取地址符&，解引用符*。
二元运算符作用于两个对象，如相等==，乘法运算符*。
函数调用也是一种特殊运算符，它对运算对象的数量没有限制。

在表达式求值过程，运算对象常常由一种类型转换成另一种类型。
小整数类型（bool、char、short）通常会被提升成较大的整数类型，主要是int。

当运算符作用于类类型的运算对象时，用户可自行定义其含义，这种自定义的过程称为重载运算符。
IO库的>>和<<运算符以及string对象、vector对象和迭代器使用的运算符都是重载的运算符。

布尔值不应该参与运算。

运算符%俗称取余或者取模运算符，参与取余运算的运算对象必须是整数类型。
在新标准中，除了-m导致溢出的特殊情况，其他时候(-m)/n 和 m/(-n)都等于-(m/n)，
m%(-n) 等于 m%n，(-m)%n 等于 -(m%n)。

进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象。

赋值运算符的左侧运算对象必须是一个可修改的左值。
int i = 0, j = 0, k = 0;    // 初始化而非赋值
const int = i;              // 初始化而非赋值

下面的赋值语句都是非法的：
1024 = k;   // 错误：字面值是右值
i + j = k;  // 错误：算术表达式是右值
ci = k;     // 错误：ci是常量（不可修改的）左值

成员访问运算符
点运算符和箭头运算符都可用于访问成员，其中，点运算符获取类对象的一个成员，箭头运算符与点运算符有关，表达式ptr->mem等价于(*ptr).mem。
因为解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端必须加上括号。
// 运行p的size成员，然后解引用size的结果
*p.size();  // 错误：p是一个指针，它没有名为size的成员

sizeof运算符
sizeof运算符返回一条表达式或一个类型名字所占的字节数。满足右结合律，其所得的值是一个size_t类型的常量表达式。
sizeof返回表达式结果类型的大小，并不实际计算其运算对象的值。
    对char或者类型为char的表达式执行sizeof运算，结果得1；
    对引用类型执行sizeof运算得到被引用对象所占空间的大小；
    对指针执行sizeof运算得到指针本身所占空间的大小；
    对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需有效；
    对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和；
    对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。

// 可求出数组中元素的个数
constexpr size_t sz = sizeof(ia) / sizeof(*ia);
int arr2[sz];   // 正确：sizeof返回一个常量表达式
